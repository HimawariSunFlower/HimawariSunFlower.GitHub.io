---
title: "algo"
date: 2022-10-18T16:05:27+08:00
draft: true
categories: ["algo"]
---

### 二分法
    使用条件
    排序数组（30-40% 是二分）

    当面试官要求你找一个比 O(n) 更小的时间复杂度算法的时候（99%）

    找到数组中的一个分割位置，使得左半部分满足某个条件，右半部分不满足（100%）

    找到一个最大/最小的值使得某个条件被满足（90%）

    复杂度
    时间复杂度：O(logn)

    空间复杂度：O(1)

### 双指针 
    使用条件
    滑动窗口（90%）

    时间复杂度要求 O(n) （80%是双指针）

    要求原地操作，只可以使用交换，不能使用额外空间（80%）

    有子数组 subarray / 子字符串 substring 的关键词（50%）

    有回文 Palindrome 关键词（50%）

    复杂度
    时间复杂度：O(n)

    时间复杂度与最内层循环主体的执行次数有关

    与有多少重循环无关

    空间复杂度：O(1)

    只需要分配两个指针的额外内存

### 排序算法
    复杂度
    时间复杂度：
    快速排序(期望复杂度) ： O(nlogn)
    归并排序(最坏复杂度) ： O(nlogn)
    空间复杂度：
    快速排序 ： O(1)
    归并排序 ： O(n)

### 二叉树分治 Binary Tree Divide & Conquer
    使用条件
    二叉树相关的问题（99%）
    可以一分为二去分别处理之后再合并结果（100%）
    数组相关的问题（10%）
    复杂度
    时间复杂度：O(n)
    空间复杂度：O(n) （含递归调用的栈空间最大耗费）


###  二叉搜索树非递归 BST Iterator
    使用条件
    用非递归的方式（Non-recursion / Iteration）实现二叉树的中序遍历
    常用于 BST 但不仅仅可以用于 BST
    复杂度
    时间复杂度：O(n)
    空间复杂度：O(n)

### 宽度优先搜索 BFS
    使用条件
    拓扑排序（100%）
    出现连通块的关键词（100%）
    分层遍历（100%）
    简单图最短路径（100%）
    给定一个变换规则，从初始状态变到终止状态最少几步（100%）
    复杂度
    时间复杂度：O(n+m)
    n 是点数，m 是边数
    空间复杂度：O(n)


### 深度优先搜索 DFS
    使用条件
    找满足某个条件的所有方案（99%）
    二叉树 Binary Tree 的问题（90%）
    组合问题（95%）
    问题模型：求出所有满足条件的“组合”
    判断条件：组合中的元素是顺序无关的
    排列问题（95%）
    问题模型：求出所有满足条件的“排列”
    判断条件：组合中的元素是顺序“相关”的
    不要用 DFS 的场景
    连通块问题（一定要用 BFS，否则 StackOverflow）
    拓扑排序（一定要用 BFS，否则 StackOverflow）
    一切 BFS 可以解决的问题
    复杂度
    时间复杂度：O(方案个数∗构造每个方案的时间)
    树的遍历 ：O(n)
    排列问题 ：O(n!∗n)
    组合问题 ：O(2n∗n) 2的n次方

### 动态规划 Dynamic Programming
    使用条件
    使用场景：

    求方案总数（90%）
    求最值（80%）
    求可行性（80%）
    不适用的场景：

    找所有具体的方案（准确率 99%）
    输入数据无序（除了背包问题外，准确率 60%~70%）
    暴力算法已经是多项式时间复杂度（准确率 80%）
    动态规划四要素（对比递归的四要素）：

    状态 (State) -- 递归的定义
    方程 (Function) -- 递归的拆解
    初始化 (Initialization) -- 递归的出口
    答案 (Answer) -- 递归的调用
    几种常见的动态规划：
    1. 背包型
    给出 n 个物品及其大小，问是否能挑选出一些物品装满大小为 m 的背包
    题目中通常有“和”与“差”的概念，数值会被放到状态中
    通常是二维的状态数组，前 i 个组成和为 j 状态数组的大小需要开 (n + 1) * (m + 1)
    几种背包类型：

    背包

    状态 state

    dp[i][j] 表示前 i 个数里挑若干个数是否能组成和为 j
    方程 function

    dp[i][j] = dp[i - 1][j] or dp[i - 1][j - A[i - 1]] 如果 j >= A[i - 1]

    dp[i][j] = dp[i - 1][j] 如果 j < A[i - 1]

    第 i 个数的下标是 i - 1，所以用的是 A[i - 1] 而不是 A[i]

    初始化 initialization

    dp[0][0] = true

    dp[0][1...m] = false

    答案 answer

    使得 dp[n][v], 0 s <= v <= m为 true 的最大 v
    多重背包

    状态 state

    dp[i][j] 表示前 i 个物品挑出一些放到 j 的背包里的最大价值和
    方程 function

    dp[i][j] = max(dp[i - 1][j - count * A[i - 1]] + count * V[i - 1])

    其中 0 <= count <= j / A[i - 1]

    初始化 initialization

    dp[0][0..m] = 0
    答案 answer

    dp[n][m]
    2. 区间型
    题目中有 subarray / substring 的信息

    大区间依赖小区间
    用 dp[i][j] 表示数组/字符串中 i，j 这一段区间的最优值/可行性/方案总数
    状态 state

    dp[i][j] 表示数组/字符串中 i，j 这一段区间的最优值/可行性/方案总数
    方程 function

    dp[i][j] = max/min/sum/or (dp[i,j 之内更小的若干区间])
    3. 匹配型
    通常给出两个字符串

    两个字符串的匹配值依赖于两个字符串前缀的匹配值

    字符串长度为 n , m 则需要开 (n + 1) x (m + 1) 的状态数组

    要初始化 dp[i][0] 与 dp[0][i]

    通常都可以用滚动数组进行空间优化

    状态 state

    dp[i][j] 表示第一个字符串的前 i 个字符与第二个字符串的前 j 个字符怎么样怎么样(max/min/sum/or)
    4. 划分型
    是前缀型动态规划的一种, 有前缀的思想

    如果指定了要划分为几个部分：

    dp[i][j] 表示前 i 个数/字符划分为 j 个 部分的最优值/方案数/可行性
    如果没有指定划分为几个部分:

    dp[i] 表示前 i 个数/字符划分为若干个 部分的最优值/方案数/可行性
    状态 state

    指定了要划分为几个部分:dp[i][j] 表示前 i 个数/字符划分为 j 个部分的最优值/方案数/可行性

    没有指定划分为几个部分: dp[i] 表示前 i 个数/字符划分为若干个部分的最优值/方案数/可行性

    5. 接龙型
    通常会给一个接龙规则，问你最长的龙有多长

    状态表示通常为: dp[i] 表示以坐标为 i 的元素结尾的最长龙的长度

    方程通常是: dp[i] = max{dp[j] + 1}, j 的后面可以接上 i

    LIS 的二分做法选择性的掌握，但并不是所有的接龙型 DP 都可以用二分来优化

    状态 state

    状态表示通常为: dp[i] 表示以坐标为 i 的元素结尾的最长龙的长度
    方程 function

    dp[i] = max{dp[j] + 1}, j 的后面可以接上 i

    复杂度
    时间复杂度:
    O(状态总数∗每个状态的处理耗费)
    等于 O(状态总数∗决策数)

    空间复杂度
    O(状态总数)(不使用滚动数组优化)
    O(状态总数/n)(使用滚动数组优化,n是被滚动掉的那一个维度)



### 堆 Heap

    使用条件
    找最大值或者最小值（60%）
    找第 k 大（ pop k 次 复杂度 O(nlogk) ）（50%）
    要求 logn 时间对数据进行操作（40%）
    堆不能解决的问题
    查询比某个数大的最小值/最接近的值（平衡排序二叉树 Balanced BST 才可以解决）
    找某段区间的最大值最小值（线段树 SegmentTree 可以解决）
    O(n) 找第 k 大 (使用快排中的 partition 操作)


### 并查集 Union Find
    使用条件
    需要查询图的连通状况的问题
    需要支持快速合并两个集合的问题
    复杂度
    时间复杂度 union O(1), find O(1)
    空间复杂度 O(n)

### 字典树 Trie
    使用条件
    需要查询包含某个前缀的单词 / 字符串是否存在
    字符矩阵中找单词的问题
    复杂度
    时间复杂度：
    O(L) 增删查改
    空间复杂度：
    O(N∗L) N 是单词书、L 是单词长度

### LRU 缓存
    复杂度
    时间复杂度：get O(1)，set O(1)
    空间复杂度：O(n)